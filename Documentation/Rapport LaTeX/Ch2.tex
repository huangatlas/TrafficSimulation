IDM est un modèle qui est basé sur l'état, c'est-à-dire quand on précise un moment, on peut déterminer les états (position, vitesse...) des voiture, et donc on peut afficher les voiture sur l'écran. Ce que l'on a besoin, c'est seulement une boucle où on mettre à jour les positions des voitures sur l'écran. A partir de cette idée, nous avons établi deux structures nécéssaires et l'algorithme principale.


Les structures de voiture et de la configuration sont définies ci-après:
\begin{lstlisting}
nouvelle structure Config
{
    /** Paramètres pour l'affichage */
     windowWidth:entier;
    windowHeight:entier;
       roadWidth:réel; 
        carWidth:réel; 
       carLength:réel; 
     
    /** (Longueur(m) virtuelle de la route/windowWidth(pixel). */
    roadVirtualLengthFactor:réel; 
    
    /** Paramètres fonctionals */
    v0:réel; /**La vitesse désirée(km/h)*/    
     T:réel; /**Temps de réaction*/
    s0:réel; /**Gap minimal*/
     a:réel; /**Accélération*/ 
     b:réel; /**Décélération*/
};

nouvelle structure Car
{
    x:réel; /**La postion courante*/
    v:réel; /**La vitesse courante*/
    a:réel; /**L'accélération*/
};
\end{lstlisting}

Et les algorithmes que nous avons créés sont décrits au-dessous. Le premier est l'algorithme fondamental, qui décrit le procédure d'exécution de l'application entière.
%Algo main
\begin{algorithm}[H]
\caption{Algorithme fondamental de l'affichage des voitures}
\label{algo:main}
\algsetup{indent=3em}
\begin{algorithmic}[1]
\REQUIRE { entrées : config : Config initialisé du fichier de Configuration, \\
\makebox[40mm]{  }cars : un tableau de Car initialisé}
\ENSURE { sortie : Une file de voiture simulée sur l'écran }
%\STATE ini
\WHILE[La boucle qui dure jusqu'à la fin]{vrai} 
\STATE Dessiner l'arrière plan
\FORALL{car dans le tableau Cars}
\STATE Dessiner la voiture sur l'écran
\ENDFOR
\STATE Mettre à jour les paramètres des voitures présentés par cars
\ENDWHILE
\end{algorithmic}
\end{algorithm}


Algorithme ci-dessous est un sous-algorithme qui présente le moyen de renouvellement des paramètres des voitures.
%Algo updateCars
\begin{algorithm}
\caption{Sous-algorithme pour renover les paramètres des voitures}
\label{algo:updatecars}
\algsetup{indent=3em}

\begin{algorithmic}
\REQUIRE { entrées : cars : un tableau de Car}
\ENSURE { sortie : Le même tableau des voitures avec les paramètres renouvelés.}
\FORALL{car dans le tableau Cars}
	\STATE Mettre à jour la position $x$ des voitures
	\STATE Mettre à jour la vitesse $v$ des voitures
	\STATE /* C'est la partie la plus importante, qui signifie l'action du conducteur intelligent et qui applique le modèle IDM */
	\STATE Mettre à jour l'accélération $a$ des voitures
\ENDFOR

\end{algorithmic}
\end{algorithm}


L'algorithme suivant est la partie du coeur, qui applique le modèle IDM. C'est un sous-algorithme plus détaillé sur la méthode pour mettre à jour le paramètre de l'accélération.
%Algo updateAcceleration
\begin{algorithm}[H]
\caption{Sous-algorithme pour mettre à jour le paramètre de l'accélération}
\label{algo:updateAcce}
\algsetup{indent=3em}
\begin{algorithmic}[1.1.1]
\REQUIRE { entrées : cars : un tableau de $n$ Car,\\
\makebox[33mm]{  }config : Config initialisé du fichier de Configuration}
\ENSURE { sortie : Le même tableau des voitures avec les paramètres d'accélération renouvelés.}
\FOR{i de $1$ à $n-1$}
	\STATE $car[i].a\leftarrow config.a
	\left[1-\left(\frac{car[i].v}{config.v_{0}}\right)^4-
		\left(
			\frac{config.s_{0}+car[i].v*config.T+\frac{car[i].v*(car[i].v-car[i+1].v)}{2\sqrt{config.a*config.b}}}{car[i+1].x-car[i].x}
		\right)^{2}
	\right]$
\ENDFOR

\end{algorithmic}
\end{algorithm}