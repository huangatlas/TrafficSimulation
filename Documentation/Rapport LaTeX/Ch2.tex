IDM est un modèle qui est basé sur l'état, c'est-à-dire quand on précise un moment, on peut déterminer les états (position, vitesse...) des voiture, et donc on peut affichier les voiture sur l'écran. Ce que l'on a besoin, c'est seulement une boucle où on mettre à jour les positions des voitures sur l'écran. A partir de cette idée, nous avons établi les structures nécéssaires et l'algorithme principale.

\section{Structures des données}
Les structures de voiture et de la configuration sont définies ci-après:
\begin{lstlisting}
nouvelle structure Config
{
    /** Paramètres pour l'affichage */
     windowWidth:entier;
    windowHeight:entier;
       roadWidth:réel; 
        carWidth:réel; 
       carLength:réel; 
     
    /** Positions des deux feux sont spécifiées en fonction 
      de leurs proportions to the windowWidth*/
		trafficLightPosition1=0.3
		trafficLightPosition2=0.6
    lightChangeDelayWhenSynchronized:entier;
		lightDurationWhenSynchronized:entier;
		
		/** (Longueur(m) virtuelle de la route/windowWidth(pixel). */
    		roadVirtualLengthFactor:réel;
    		
    /** Paramètres fonctionals */
    v0:réel; /**La vitesse désirée(km/h)*/    
     T:réel; /**Temps de réaction*/
    s0:réel; /**Gap minimal*/
     a:réel; /**Accélération*/ 
     b:réel; /**Décélération*/
     moyen:entier; /**Interval moyen du temps d'arrivée en ms*/
};

nouvelle structure Car
{
    x:réel; /**La postion courante*/
    v:réel; /**La vitesse courante*/
    a:réel; /**L'accélération*/
};
\end{lstlisting}


Ces deux structures sont plutôt ordinaires, ce qui est plus intéressante est la structure de la liste des voirutres. Pour dessiner les voitures sur l'écran, il faut que chacune voiture est une variable de type Car. La question est que le nombre des voitures n'est pas défini, ou peut est très grand. Donc on ne peut bien sûr pas allouer pour chacune voiture un espace mémoire à stocker les donnée. Alors ce que l'on fait, c'est définir une nouvelle structure \textit{CarList} qui est comme une liste circulaire. L'esprit c'est que en fait on s'intéresse seulement aux voitures qui sont actuellement sur l'écran. Quand une voiture sort de l'écran (en ce moment-là la fonction \textit{carOut} sera invoquée), son espace de stockage est prêt pour être réutilisé.


La structure \textit{CarList}:
\begin{lstlisting}
nouvelle structure Car
{
    Car* carArray;//Le tableau des voitures
    int count;//Le nombre des voitures qui sont actuellement sur l'écran
    int size;//La taille du tableau
    int firstCar;//L'index de la première voiture sur l'écran
    int lastCar;//L'index de la dernière voiture sur l'écran
};

\end{lstlisting}

\section{Algorithme principal}
Les algorithmes que nous avons créés sont décrits au-dessous. Le premier est l'algorithme fondamental, qui décrit le procédure d'exécution de l'application entière.
%Algo main
\begin{algorithm}[H]
\caption{Algorithme fondamental de l'affichage des voitures}
\label{algo:main}
\algsetup{indent=3em}
\begin{algorithmic}[1]
\REQUIRE { entrées : config : Config initialisé du fichier de Configuration, \\
\makebox[40mm]{  }cars : un tableau de Car initialisé}
\ENSURE { sortie : Une file de voiture simulée sur l'écran }
%\STATE ini
\WHILE[La boucle qui dure jusqu'à la fin]{vrai} 
\STATE Dessiner l'arrière plan
\FORALL{car dans le tableau Cars}
\STATE Dessiner la voiture sur l'écran
\ENDFOR
\STATE Mettre à jour les paramètres des voitures présentés par cars
\ENDWHILE
\end{algorithmic}
\end{algorithm}


Algorithme ci-dessous est un sous-algorithme qui présente le moyen de renouvellement des paramètres des voitures.
%Algo updateCars
\begin{algorithm}
\caption{Sous-algorithme pour renover les paramètres des voitures}
\label{algo:updatecars}
\algsetup{indent=3em}

\begin{algorithmic}
\REQUIRE { entrées : cars : un tableau de Car}
\ENSURE { sortie : Le même tableau des voitures avec les paramètres renouvelés.}
\FORALL{car dans le tableau Cars}
	\STATE Mettre à jour la position $x$ des voitures
	\STATE Mettre à jour la vitesse $v$ des voitures
	\STATE /* C'est la partie la plus importante, qui signifie l'action du conducteur intelligent et qui applique le modèle IDM */
	\STATE Mettre à jour l'accélération $a$ des voitures
\ENDFOR

\end{algorithmic}
\end{algorithm}


L'algorithme suivant est la partie du coeur, qui applique le modèle IDM. C'est un sous-algorithme plus détaillé sur la méthode pour mettre à jour le paramètre de l'accélération.
%Algo updateAcceleration
\begin{algorithm}[H]
\caption{Sous-algorithme pour mettre à jour le paramètre de l'accélération}
\label{algo:updateAcce}
\algsetup{indent=3em}
\begin{algorithmic}[1.1.1]
\REQUIRE { entrées : cars : un tableau de $n$ Car,\\
\makebox[33mm]{  }config : Config initialisé du fichier de Configuration}
\ENSURE { sortie : Le même tableau des voitures avec les paramètres d'accélération renouvelés.}
\FOR{i de $1$ à $n-1$}
	\STATE $car[i].a\leftarrow config.a
	\left[1-\left(\frac{car[i].v}{config.v_{0}}\right)^4-
		\left(
			\frac{config.s_{0}+car[i].v*config.T+\frac{car[i].v*(car[i].v-car[i+1].v)}{2\sqrt{config.a*config.b}}}{car[i+1].x-car[i].x}
		\right)^{2}
	\right]$
\ENDFOR

\end{algorithmic}
\end{algorithm}


\section{Temps d'arrivée des voitures}
Pour être plus réel, nous considérons que l'interval entre le temps d'arrivée des deux voitures contiguës doit être aléatoire. L'utilisateur peut fixer un temps moyen dans le fichier de configuration(le nom du paramètre est \textit{moyen}), et l'application va générer un temps aléatoire exponentiel de ce moyen pendant l'exécution.


Notre méthode de génération d'un temps aléatoire unifié à partir du moyen est indiquée par l'équation suivante. L'opérateur \textit{ln} est utilisé pour que la variable générée soit plus unifiée.
\begin{subequations}
\begin{align}
%\label{equ:ch2_random}
t=(-moyen*(ln(rand()\%1001*0.001f)))\%(2*moyen)
\end{align}
\end{subequations}

\section{Synchronisation des feux}
Pendant l'exécution de notre application, on peut changer manuellement les deux feux par appuyer sur le clavier 1 et 2. Mais on peut aussi synchroniser les deux feux pour qu'ils puissent changer automatiquement. L'esprit c'est que le délai de changement entre les deux feux doit être bien considérer. Par exemple, quand le premier feu devient vert, une voiture démarre, alors c'est mieux qu'elle touve que le deuxième feu devient aussi vert quand elle arrive. Alors nous somme surpris que ce projet nous donne une chance à reprendre la physique que nous avons apris au lycée.


Le délai de changement entre les deux feux est calculé automatiquement selon : 
\begin{subequations}
\begin{align}
t=\frac{\sqrt{2ad}}{a}
\end{align}
\end{subequations}


L'utilisateur peut aussi fixer ce paramètre à l'aide du fichier de la configuration. Ça concerne le paramètre \textit{lightChangeDelayWhenSynchronized}, qui est initialement -1 qui veut dire \textbf{intelligent}.